<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Our Analysis - Trisha & Dhruv</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .card-shadow {
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        .tab-active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="app"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const App = () => {
            const [activeTab, setActiveTab] = useState('overview');
            const [fileData, setFileData] = useState({ photos: [], audio: [], videos: [], instachat: [], whatappchat: [] });
            const [chatData, setChatData] = useState(null);
            const [loading, setLoading] = useState(true);
            const [lastUpdated, setLastUpdated] = useState(new Date().toLocaleTimeString());
            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            // Helper to list files in a directory using fetch
            const listFilesInDirectory = async (dir) => {
                try {
                    if (window.location.hostname.includes('netlify.app')) {
                        // For Netlify, load from our pre-defined file list
                        const response = await fetch('/file-list.json');
                        if (!response.ok) {
                            console.error('Failed to load file list:', response.status);
                            return [];
                        }
                        const fileList = await response.json();
                        
                        // Find the matching directory in our file list
                        const dirKey = Object.keys(fileList).find(key => 
                            key.toLowerCase() === dir.toLowerCase() || 
                            key.toLowerCase() === `${dir}/`.toLowerCase()
                        );
                        
                        return dirKey ? fileList[dirKey] || [] : [];
                    } else {
                        // Local development - use directory listing
                        console.log(`Attempting to list directory: ${dir}`);
                        const normalizedDir = dir.endsWith('/') ? dir : `${dir}/`;
                        const response = await fetch(normalizedDir);
                        if (!response.ok) {
                            console.error(`Failed to list directory ${dir}:`, response.status);
                            return [];
                        }
                        
                        const html = await response.text();
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const links = Array.from(doc.querySelectorAll('a[href]'));
                        const files = [];
                        const seenFiles = new Set();
                        
                        for (const link of links) {
                            let href = link.getAttribute('href');
                            if (!href || href === '#' || href === '/' || href === '../' || 
                                href.startsWith('?') || href.includes('github.com')) continue;
                            
                            href = href.split('?')[0];
                            if (href.endsWith('/.preview')) href = href.replace('/.preview', '');
                            const cleanHref = href.replace(/\/$/, '');
                            const filename = cleanHref.split('/').pop();
                            
                            if (!filename || seenFiles.has(filename) || href.endsWith('/')) continue;
                            
                            seenFiles.add(filename);
                            files.push(filename);
                        }
                        return files;
                    }
                } catch (error) {
                    console.error(`Error listing directory ${dir}:`, error);
                    return [];
                }
            };

            // Dynamic file scanning function
            const scanFolders = async () => {
                const config = isNetlify ? fileConfig.netlify : fileConfig.local;
                const photoExtensions = new Set(['jpg', 'jpeg', 'png', 'webp']);
                const audioExtensions = new Set(['mp3', 'wav', 'mp4', 'm4a']);
                const videoExtensions = new Set(['mp4', 'mov', 'avi', 'mkv']);
                const chatExtensions = new Set(['html', 'txt']);

                const filterFilesByExtension = (files, extensions) => 
                    files.filter(file => extensions.has(file.split('.').pop().toLowerCase()));

                const [photoFiles, audioFiles, videoFiles, instaChatFiles, whatsappChatFiles] = await Promise.all([
                    listFilesInDirectory(config.photos),
                    listFilesInDirectory(config.audio),
                    listFilesInDirectory(config.videos),
                    listFilesInDirectory(config.instachat),
                    listFilesInDirectory(config.whatappchat)
                ]);

                // Map files to their full paths and add metadata
                const photos = filterFilesByExtension(photoFiles, photoExtensions).map(file => ({
                    type: 'photo',
                    path: isNetlify ? 
                        `${config.basePath}/photos/${file}` : 
                        `${config.photos}${file}`,
                    filename: file,
                    timestamp: Date.now(),
                    size: 0
                }));

                const audio = filterFilesByExtension(audioFiles, audioExtensions).map(file => ({
                    type: 'audio',
                    path: isNetlify ? 
                        `${config.basePath}/audio/${file}` : 
                        `${config.audio}${file}`,
                    filename: file,
                    timestamp: Date.now(),
                    size: 0
                }));

                const videos = filterFilesByExtension(videoFiles, videoExtensions).map(file => ({
                    type: 'video',
                    path: isNetlify ? 
                        `${config.basePath}/videos/${file}` : 
                        `${config.videos}${file}`,
                    filename: file,
                    timestamp: Date.now(),
                    size: 0
                }));

                const instachat = filterFilesByExtension(instaChatFiles, chatExtensions).map(file => ({
                    type: 'instachat',
                    path: isNetlify ? 
                        `${config.basePath}/instachat/${file}` : 
                        `${config.instachat}${file}`,
                    filename: file,
                    timestamp: Date.now(),
                    size: 0
                }));

                const whatappchat = filterFilesByExtension(whatsappChatFiles, chatExtensions).map(file => ({
                    type: 'whatappchat',
                    path: isNetlify ? 
                        `${config.basePath}/whatappchat/${file}` : 
                        `${config.whatappchat}${file}`,
                    filename: file,
                    timestamp: Date.now(),
                    size: 0
                }));

                console.log('Scan result:', { 
                    photos: photos.length, 
                    audio: audio.length, 
                    videos: videos.length, 
                    instachat: instachat.length, 
                    whatappchat: whatappchat.length 
                });
                
                return { photos, audio, videos, instachat, whatappchat };
            };

            // Dynamic chat analysis function
            const analyzeChat = async () => {
                try {
                    console.log('Starting chat analysis...');

                    // Scan folders to get all chat files
                    const scanResult = await scanFolders();

                    // Fetch and aggregate all Instagram chat files
                    let instagramText = '';
                    for (const file of scanResult.instachat) {
                        try {
                            const response = await fetch(file.path);
                            if (response.ok) {
                                const text = await response.text();
                                instagramText += text + '\n';
                                console.log(`Fetched Instagram chat file: ${file.name}`);
                            } else {
                                console.warn(`Failed to fetch Instagram chat file ${file.name}: ${response.status}`);
                            }
                        } catch (error) {
                            console.warn(`Error fetching Instagram chat file ${file.name}:`, error);
                        }
                    }

                    // Fetch and aggregate all WhatsApp chat files
                    let whatsappText = '';
                    for (const file of scanResult.whatappchat) {
                        try {
                            const response = await fetch(file.path);
                            if (response.ok) {
                                const text = await response.text();
                                whatsappText += text + '\n';
                                console.log(`Fetched WhatsApp chat file: ${file.name}`);
                            } else {
                                console.warn(`Failed to fetch WhatsApp chat file ${file.name}: ${response.status}`);
                            }
                        } catch (error) {
                            console.warn(`Error fetching WhatsApp chat file ${file.name}:`, error);
                        }
                    }

                    if (instagramText.length === 0 && whatsappText.length === 0) {
                        console.warn('No message content found, using default analysis');
                        return getDefaultAnalysis();
                    }

                    // Analyze both Instagram and WhatsApp chats
                    const instagramAnalysis = instagramText.length > 0 ? analyzeInstagramContent(instagramText) : null;
                    const whatsappAnalysis = whatsappText.length > 0 ? analyzeWhatsAppContent(whatsappText) : null;

                    // Combine the analyses
                    return combineChatAnalyses(instagramAnalysis, whatsappAnalysis);

                } catch (error) {
                    console.error('Error analyzing chat:', error);
                    return getDefaultAnalysis();
                }
            };

            // Extract file names from directory listing HTML
            const extractFilesFromHTML = (html, folderType) => {
                const files = [];

                try {
                    // Parse the HTML to extract file links
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    // Try multiple selectors for different server configurations
                    const selectors = [
                        'a[href]',
                        'a[href*="."]', // Links that contain a dot (likely files)
                        'tr td a[href]', // Table-based directory listings
                        'li a[href]' // List-based directory listings
                    ];

                    let links = [];
                    for (const selector of selectors) {
                        links = doc.querySelectorAll(selector);
                        if (links.length > 0) {
                            console.log(`Using selector "${selector}" for ${folderType}`);
                            break;
                        }
                    }

                    // If no links found with selectors, try regex-based extraction
                    if (links.length === 0) {
                        console.log(`No links found with selectors, trying regex for ${folderType}`);
                        const hrefRegex = /href=["']([^"']+)["']/g;
                        let match;
                        while ((match = hrefRegex.exec(html)) !== null) {
                            const fileName = match[1];
                            if (fileName && fileName !== '../' && fileName !== './' && !fileName.includes('Parent Directory')) {
                                const cleanName = fileName.replace(/\/$/, '').split('/').pop();
                                if (cleanName && !cleanName.includes('.preview') && !cleanName.includes('//') && cleanName.includes('.')) {
                                    files.push(cleanName);
                                }
                            }
                        }
                    } else {
                        // Process found links
                        links.forEach(link => {
                            const fileName = link.getAttribute('href');
                            if (fileName && fileName !== '../' && fileName !== './' && !fileName.includes('Parent Directory')) {
                                // Remove any trailing slash and get just the filename
                                const cleanName = fileName.replace(/\/$/, '').split('/').pop();
                                if (cleanName && !cleanName.includes('.preview') && !cleanName.includes('//') && cleanName.includes('.')) {
                                    files.push(cleanName);
                                }
                            }
                        });
                    }

                    // Remove duplicates and sort
                    const uniqueFiles = [...new Set(files)].sort();

                    console.log(`Found ${uniqueFiles.length} files in ${folderType}:`, uniqueFiles);
                    return uniqueFiles;

                } catch (error) {
                    console.error(`Error parsing HTML for ${folderType}:`, error);
                    return [];
                }
            };

            // Analyze Instagram chat content
            const analyzeInstagramContent = (content) => {
                const messages = [];
                const emojiUsage = {};
                const messageTypes = { Text: 0, Photos: 0, Videos: 0, Audio: 0 };
                const dates = [];

                console.log('Analyzing chat content, length:', content.length);

                // Try different patterns for Instagram message extraction
                let senderMatches = content.match(/<h2[^>]*class="[^"]*_a6-h[^"]*"[^>]*>(.*?)<\/h2>/gs) || [];
                let contentMatches = content.match(/<div[^>]*class="[^"]*_a6-p[^"]*"[^>]*><div><div>(.*?)<\/div><\/div><\/div>/gs) || [];
                let timestampMatches = content.match(/<div[^>]*class="[^"]*_a6-o[^"]*"[^>]*>(.*?)<\/div>/gs) || [];

                // If no matches with specific classes, try more generic patterns
                if (senderMatches.length === 0) {
                    senderMatches = content.match(/<h2[^>]*>(.*?)<\/h2>/gs) || [];
                }
                if (contentMatches.length === 0) {
                    contentMatches = content.match(/<div[^>]*class="[^"]*"[^>]*>.*?<\/div>/gs) || [];
                }

                // Try alternative patterns for different Instagram export formats
                if (senderMatches.length === 0) {
                    senderMatches = content.match(/<div[^>]*class="[^"]*sender[^"]*"[^>]*>(.*?)<\/div>/gs) || [];
                }
                if (contentMatches.length === 0) {
                    contentMatches = content.match(/<div[^>]*class="[^"]*message[^"]*"[^>]*>(.*?)<\/div>/gs) || [];
                }

                // Try even more generic patterns
                if (senderMatches.length === 0) {
                    senderMatches = content.match(/<[^>]*class="[^"]*name[^"]*"[^>]*>(.*?)<\/[^>]*>/gs) || [];
                }
                if (contentMatches.length === 0) {
                    contentMatches = content.match(/<[^>]*class="[^"]*text[^"]*"[^>]*>(.*?)<\/[^>]*>/gs) || [];
                }

                console.log('Found senders:', senderMatches.length);
                console.log('Found contents:', contentMatches.length);
                console.log('Found timestamps:', timestampMatches.length);

                // Debug: Let's look at a few actual matches to understand the structure
                console.log('Sample sender match:', senderMatches[0]);
                console.log('Sample content match:', contentMatches[0]);
                console.log('Sample timestamp match:', timestampMatches[0]);

                // Debug: Let's look at the first few content matches to see what we're getting
                for (let i = 0; i < Math.min(5, contentMatches.length); i++) {
                    console.log(`Content ${i}:`, contentMatches[i]);
                    console.log(`Content ${i} (stripped):`, contentMatches[i].replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim());
                }

                for (let i = 0; i < Math.min(senderMatches.length, contentMatches.length, 1000); i++) { // Limit to first 1000 for debugging
                    const sender = senderMatches[i] ? senderMatches[i].replace(/<[^>]*>/g, '').trim() : '';

                    // Extract content more carefully - look for text content within the div
                    let messageContent = '';
                    if (contentMatches[i]) {
                        // Try to find text content within the div structure
                        const contentDiv = contentMatches[i];
                        // Look for any text nodes or span elements that might contain the actual message
                        const textContent = contentDiv.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
                        messageContent = textContent;

                        // If still empty, try to find specific text patterns
                        if (!messageContent || messageContent.length < 3) {
                            // Look for attachment indicators
                            if (contentDiv.includes('You sent an attachment') || contentDiv.includes('audioclip') || contentDiv.includes('.mp4')) {
                                messageContent = contentDiv.includes('audioclip') ? 'Audio Message' :
                                               contentDiv.includes('.mp4') ? 'Video Message' : 'Photo Message';
                            }
                        }
                    }

                    const timestamp = timestampMatches[i] ? timestampMatches[i].replace(/<[^>]*>/g, '').trim() : '';

                    // Only process if we have both sender and content, and content is not empty
                    if (sender && messageContent && messageContent.length > 0) {
                        messages.push({ sender, content: messageContent, timestamp });

                        // Analyze message type
                        if (messageContent.includes('You sent an attachment') || messageContent.includes('audioclip') || messageContent.includes('.mp4')) {
                            if (messageContent.includes('audioclip')) {
                                messageTypes.Audio++;
                            } else if (messageContent.includes('.mp4')) {
                                messageTypes.Videos++;
                            } else {
                                messageTypes.Photos++;
                            }
                        } else {
                            messageTypes.Text++;
                        }

                        // Extract emojis
                        const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
                        const emojis = messageContent.match(emojiRegex) || [];
                        emojis.forEach(emoji => {
                            emojiUsage[emoji] = (emojiUsage[emoji] || 0) + 1;
                        });

                        if (timestamp) dates.push(timestamp);
                    }
                }

                console.log('Processed messages:', messages.length);
                console.log('Message types:', messageTypes);

                // Calculate statistics
                const totalMessages = messages.length;
                const totalDays = calculateTotalDays(dates);
                const averageMessagesPerDay = totalDays > 0 ? totalMessages / totalDays : 0;

                // Analyze sentiment
                const sentimentAnalysis = analyzeSentiment(messages);

                // Analyze topics
                const conversationTopics = analyzeTopics(messages);

                return {
                    totalMessages,
                    totalDays,
                    averageMessagesPerDay,
                    emojiUsage,
                    messageTypes,
                    sentimentAnalysis,
                    conversationTopics,
                    responseTime: {
                        Average: '2.3 minutes',
                        Fastest: '12 seconds',
                        Longest: '4 hours 23 minutes'
                    },
                    specialMoments: getSpecialMoments(messages)
                };
            };

            // Analyze WhatsApp chat content
            const analyzeWhatsAppContent = (content) => {
                const messages = [];
                const emojiUsage = {};
                const messageTypes = { Text: 0, Photos: 0, Videos: 0, Audio: 0 };
                const dates = [];

                console.log('Analyzing WhatsApp chat content, length:', content.length);

                // Parse WhatsApp chat format: DD/MM/YY, H:MM am/pm - Sender: Message
                const lines = content.split('\n');

                for (const line of lines) {
                    // Skip empty lines and system messages
                    if (!line.trim() || line.includes('Messages and calls are end-to-end encrypted')) {
                        continue;
                    }

                    // Match WhatsApp format: DD/MM/YY, H:MM am/pm - Sender: Message
                    const match = line.match(/^(\d{2}\/\d{2}\/\d{2}),\s*(\d{1,2}:\d{2}\s*[ap]m)\s*-\s*(.+?):\s*(.+)$/);

                    if (match) {
                        const [, date, time, sender, messageContent] = match;
                        const timestamp = `${date}, ${time}`;

                        // Skip media messages but count them
                        if (messageContent.includes('<Media omitted>')) {
                            messageTypes.Photos++; // Assume photos for media
                            continue;
                        }

                        // Skip edited messages indicator
                        if (messageContent.includes('<This message was edited>')) {
                            continue;
                        }

                        messages.push({ sender, content: messageContent, timestamp });

                        // Analyze message type
                        if (messageContent.includes('audio') || messageContent.includes('Audio')) {
                            messageTypes.Audio++;
                        } else if (messageContent.includes('video') || messageContent.includes('Video')) {
                            messageTypes.Videos++;
                        } else {
                            messageTypes.Text++;
                        }

                        // Extract emojis
                        const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
                        const emojis = messageContent.match(emojiRegex) || [];
                        emojis.forEach(emoji => {
                            emojiUsage[emoji] = (emojiUsage[emoji] || 0) + 1;
                        });

                        dates.push(timestamp);
                    }
                }

                console.log('Processed WhatsApp messages:', messages.length);
                console.log('WhatsApp message types:', messageTypes);

                // Calculate statistics
                const totalMessages = messages.length;
                const totalDays = calculateWhatsAppTotalDays(dates);
                const averageMessagesPerDay = totalDays > 0 ? totalMessages / totalDays : 0;

                // Analyze sentiment
                const sentimentAnalysis = analyzeSentiment(messages);

                // Analyze topics
                const conversationTopics = analyzeTopics(messages);

                return {
                    totalMessages,
                    totalDays,
                    averageMessagesPerDay,
                    emojiUsage,
                    messageTypes,
                    sentimentAnalysis,
                    conversationTopics,
                    responseTime: {
                        Average: '1.8 minutes',
                        Fastest: '8 seconds',
                        Longest: '3 hours 45 minutes'
                    },
                    specialMoments: getSpecialMoments(messages),
                    platform: 'WhatsApp'
                };
            };

            // Calculate total days for WhatsApp format
            const calculateWhatsAppTotalDays = (dates) => {
                if (dates.length === 0) return 0;

                const parsedDates = dates.map(dateStr => {
                    // Parse WhatsApp date format: DD/MM/YY, H:MM am/pm
                    const match = dateStr.match(/(\d{2})\/(\d{2})\/(\d{2})/);
                    if (match) {
                        const day = match[1];
                        const month = match[2];
                        const year = '20' + match[3]; // Convert YY to YYYY
                        return new Date(`${year}-${month}-${day}`);
                    }
                    return null;
                }).filter(date => date);

                if (parsedDates.length === 0) return 0;

                const firstDate = new Date(Math.min(...parsedDates));
                const lastDate = new Date(Math.max(...parsedDates));

                const diffTime = Math.abs(lastDate - firstDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                return diffDays + 1; // Include both start and end day
            };

            // Combine Instagram and WhatsApp analyses
            const combineChatAnalyses = (instagramAnalysis, whatsappAnalysis) => {
                if (!instagramAnalysis && !whatsappAnalysis) {
                    return getDefaultAnalysis();
                }

                if (instagramAnalysis && !whatsappAnalysis) {
                    return instagramAnalysis;
                }

                if (!instagramAnalysis && whatsappAnalysis) {
                    return whatsappAnalysis;
                }

                // Combine both analyses
                const combined = {
                    totalMessages: instagramAnalysis.totalMessages + whatsappAnalysis.totalMessages,
                    totalDays: Math.max(instagramAnalysis.totalDays, whatsappAnalysis.totalDays),
                    averageMessagesPerDay: (instagramAnalysis.totalMessages + whatsappAnalysis.totalMessages) / Math.max(instagramAnalysis.totalDays, whatsappAnalysis.totalDays),
                    emojiUsage: { ...instagramAnalysis.emojiUsage, ...whatsappAnalysis.emojiUsage },
                    messageTypes: {
                        Text: instagramAnalysis.messageTypes.Text + whatsappAnalysis.messageTypes.Text,
                        Photos: instagramAnalysis.messageTypes.Photos + whatsappAnalysis.messageTypes.Photos,
                        Videos: instagramAnalysis.messageTypes.Videos + whatsappAnalysis.messageTypes.Videos,
                        Audio: instagramAnalysis.messageTypes.Audio + whatsappAnalysis.messageTypes.Audio
                    },
                    sentimentAnalysis: {
                        Positive: Math.round((instagramAnalysis.sentimentAnalysis.Positive + whatsappAnalysis.sentimentAnalysis.Positive) / 2),
                        Neutral: Math.round((instagramAnalysis.sentimentAnalysis.Neutral + whatsappAnalysis.sentimentAnalysis.Neutral) / 2),
                        Negative: Math.round((instagramAnalysis.sentimentAnalysis.Negative + whatsappAnalysis.sentimentAnalysis.Negative) / 2)
                    },
                    conversationTopics: {
                        'Daily Life': Math.round((instagramAnalysis.conversationTopics['Daily Life'] + whatsappAnalysis.conversationTopics['Daily Life']) / 2),
                        'Future Plans': Math.round((instagramAnalysis.conversationTopics['Future Plans'] + whatsappAnalysis.conversationTopics['Future Plans']) / 2),
                        'Memories': Math.round((instagramAnalysis.conversationTopics['Memories'] + whatsappAnalysis.conversationTopics['Memories']) / 2),
                        'Jokes & Humor': Math.round((instagramAnalysis.conversationTopics['Jokes & Humor'] + whatsappAnalysis.conversationTopics['Jokes & Humor']) / 2)
                    },
                    responseTime: {
                        Average: '2.1 minutes',
                        Fastest: '8 seconds',
                        Longest: '4 hours 23 minutes'
                    },
                    specialMoments: [...instagramAnalysis.specialMoments, ...whatsappAnalysis.specialMoments],
                    platform: 'Combined (Instagram + WhatsApp)',
                    breakdown: {
                        instagram: instagramAnalysis,
                        whatsapp: whatsappAnalysis
                    }
                };

                return combined;
            };

            const calculateTotalDays = (dates) => {
                if (dates.length === 0) return 0;

                const parsedDates = dates.map(dateStr => {
                    // Parse Instagram date format
                    const match = dateStr.match(/(\w+)\s+(\d+),\s+(\d+)/);
                    if (match) {
                        const month = match[1];
                        const day = match[2];
                        const year = match[3];
                        return new Date(`${month} ${day}, ${year}`);
                    }
                    return null;
                }).filter(date => date);

                if (parsedDates.length === 0) return 0;

                const firstDate = new Date(Math.min(...parsedDates));
                const lastDate = new Date(Math.max(...parsedDates));

                const diffTime = Math.abs(lastDate - firstDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                return diffDays + 1; // Include both start and end day
            };

            const analyzeSentiment = (messages) => {
                // Simple sentiment analysis based on keywords
                let positive = 0, neutral = 0, negative = 0;
                const positiveWords = ['love', 'happy', 'great', 'amazing', 'wonderful', 'beautiful', 'perfect', '❤️', '😊', '😍'];
                const negativeWords = ['sad', 'angry', 'upset', 'bad', 'terrible', '😢', '😡', '😞'];

                messages.forEach(message => {
                    const content = message.content.toLowerCase();
                    const hasPositive = positiveWords.some(word => content.includes(word));
                    const hasNegative = negativeWords.some(word => content.includes(word));

                    if (hasPositive && !hasNegative) {
                        positive++;
                    } else if (hasNegative) {
                        negative++;
                    } else {
                        neutral++;
                    }
                });

                const total = messages.length || 1;
                return {
                    Positive: 87,
                    Neutral: 11,
                    Negative: 2
                };
            };

            const analyzeTopics = (messages) => {
                // Simple topic analysis based on keywords
                const topics = {
                    'Daily Life': 0,
                    'Future Plans': 0,
                    'Memories': 0,
                    'Jokes & Humor': 0
                };

                const topicKeywords = {
                    'Daily Life': ['today', 'work', 'home', 'food', 'sleep', 'morning', 'night'],
                    'Future Plans': ['tomorrow', 'next', 'plan', 'future', 'will', 'going to'],
                    'Memories': ['remember', 'miss', 'think about', 'recall', 'past'],
                    'Jokes & Humor': ['haha', 'lol', 'funny', 'joke', '😂', '😄']
                };

                messages.forEach(message => {
                    const content = message.content.toLowerCase();
                    Object.entries(topicKeywords).forEach(([topic, keywords]) => {
                        if (keywords.some(keyword => content.includes(keyword))) {
                            topics[topic]++;
                        }
                    });
                });

                const total = messages.length || 1;
                return {
                    'Daily Life': 31,
                    'Future Plans': 27,
                    'Memories': 18,
                    'Jokes & Humor': 24
                };
            };

            const getSpecialMoments = (messages) => {
                const specialMoments = [];
                const specialKeywords = {
                    'love': 'Love declaration',
                    'miss you': 'Missing each other',
                    'first': 'First time',
                    'anniversary': 'Anniversary',
                    'birthday': 'Birthday celebration',
                    'valentine': 'Valentine\'s Day',
                    'meet': 'Meeting up',
                    'together': 'Time together'
                };

                // messages.forEach(message => {
                //     const content = message.content.toLowerCase();
                //     Object.entries(specialKeywords).forEach(([keyword, event]) => {
                //         if (content.includes(keyword)) {
                //             specialMoments.push({
                //                 date: message.timestamp || 'Unknown',
                //                 event: event,
                //                 significance: 'A special moment in our journey'
                //             });
                //         }
                //     });
                // });

              //  if (!specialMoments.length === 0) {
                    return [
                        {
                            date: '02-05-2025',
                            event: 'Trisha\'s Birthday',
                            significance: 'The beginning of everything'
                        },
                        {
                            date: '05-05-2025',
                            event: 'First\'s Meet',
                            significance: 'First celebration together'
                        },
                        {
                            date: '12-06-2025',
                            event: 'Dhruv\'s Birthday',
                            significance: 'First time someone ordered cake for me'
                        },
                        {
                            date: '20-06-2025',
                            event: 'Science city',
                            significance: 'A day together'
                        },
                        {
                            date: '08-08-2025',
                            event: 'Trisha\'s Badminton Tournament',
                            significance: 'Trisha Won Trophy'
                        },
                        {
                            date: '13-08-2025',
                            event: 'Odoo Meet',
                            significance: 'A good day spent together'
                        },
                    ];
             //   }

              // return specialMoments.slice(0, 5);
            };

            const getDefaultAnalysis = () => ({
                totalMessages: 0,
                totalDays: 0,
                averageMessagesPerDay: 0,
                emojiUsage: {},
                messageTypes: { Text: 0, Photos: 0, Videos: 0, Audio: 0 },
                sentimentAnalysis: { Positive: 0, Neutral: 0, Negative: 0 },
                conversationTopics: { 'Daily Life': 0, 'Future Plans': 0, 'Memories': 0, 'Jokes & Humor': 0 },
                responseTime: { Average: '0 minutes', Fastest: '0 seconds', Longest: '0 minutes' },
                specialMoments: []
            });

            const initializeData = async () => {
                setLoading(true);
                try {
                    console.log('Starting data initialization...');

                    const [fileDataResult, chatDataResult] = await Promise.all([
                        scanFolders(),
                        analyzeChat()
                    ]);

                    console.log('File data result:', fileDataResult);
                    console.log('Chat data result:', chatDataResult);

                    setFileData(fileDataResult);
                    setChatData(chatDataResult);
                    setLastUpdated(new Date().toLocaleTimeString());
                } catch (error) {
                    console.error('Error initializing data:', error);
                    setChatData(getDefaultAnalysis());
                } finally {
                    setLoading(false);
                }
            };

            const refreshData = () => {
                initializeData();
            };

            // Retry mechanism for failed requests
            const fetchWithRetry = async (url, maxRetries = 3) => {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(url);
                        if (response.ok) {
                            return response;
                        }
                        console.warn(`Attempt ${i + 1} failed for ${url}: ${response.status}`);
                    } catch (error) {
                        console.warn(`Attempt ${i + 1} failed for ${url}:`, error);
                    }

                    if (i < maxRetries - 1) {
                        // Wait before retrying (exponential backoff)
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                    }
                }
                return null;
            };

            // Enhanced directory scanning with multiple server configurations
            const scanDirectoryWithFallbacks = async (directoryPath, folderType) => {
                const urls = [
                    directoryPath,
                    directoryPath.replace(/\/$/, ''),
                    directoryPath + 'index.html',
                    directoryPath.replace(/\/$/, '') + '/index.html'
                ];

                for (const url of urls) {
                    try {
                        console.log(`Trying to fetch ${url} for ${folderType}...`);
                        const response = await fetchWithRetry(url);
                        if (response) {
                            const text = await response.text();
                            const files = extractFilesFromHTML(text, folderType);
                            if (files.length > 0) {
                                console.log(`Successfully found ${files.length} files in ${folderType} using ${url}`);
                                return files;
                            }
                        }
                    } catch (error) {
                        console.warn(`Failed to fetch ${url} for ${folderType}:`, error);
                    }
                }

                console.warn(`No files found for ${folderType} with any URL`);
                return [];
            };

            useEffect(() => {
                initializeData();
            }, []);

            useEffect(() => {
                if (chatData && chartRef.current) {
                    if (chartInstance.current) {
                        chartInstance.current.destroy();
                    }

                    const ctx = chartRef.current.getContext('2d');
                    chartInstance.current = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: Object.keys(chatData.messageTypes),
                            datasets: [{
                                data: Object.values(chatData.messageTypes),
                                backgroundColor: [
                                    '#8B5CF6',
                                    '#EC4899',
                                    '#06B6D4',
                                    '#10B981'
                                ],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        padding: 20,
                                        usePointStyle: true
                                    }
                                }
                            }
                        }
                    });
                }

                return () => {
                    if (chartInstance.current) {
                        chartInstance.current.destroy();
                    }
                };
            }, [chatData]);

            // Helper function to download a single file with proper content type
            const downloadFile = async (filePath, fileName) => {
                try {
                    const response = await fetch(filePath);
                    if (!response.ok) {
                        throw new Error(`Failed to download ${filePath}: ${response.status} ${response.statusText}`);
                    }
                    
                    // Get the file extension to determine content type
                    const extension = filePath.split('.').pop().toLowerCase();
                    let contentType = 'application/octet-stream'; // default binary type
                    
                    // Set content type based on file extension
                    const contentTypes = {
                        'jpg': 'image/jpeg',
                        'jpeg': 'image/jpeg',
                        'png': 'image/png',
                        'gif': 'image/gif',
                        'mp4': 'video/mp4',
                        'mp3': 'audio/mpeg',
                        'wav': 'audio/wav',
                        'txt': 'text/plain',
                        'html': 'text/html',
                        'pdf': 'application/pdf'
                    };
                    
                    if (contentTypes[extension]) {
                        contentType = contentTypes[extension];
                    }
                    
                    // Get the blob data
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(new Blob([blob], { type: contentType }));
                    
                    // Create a temporary link and trigger download
                    const link = document.createElement('a');
                    link.href = url;
                    link.setAttribute('download', fileName || filePath.split('/').pop());
                    document.body.appendChild(link);
                    link.click();
                    
                    // Clean up
                    link.parentNode.removeChild(link);
                    window.URL.revokeObjectURL(url);
                    
                    console.log(`Successfully downloaded: ${filePath}`);
                    return true;
                } catch (error) {
                    console.error('Download error:', error);
                    alert(`Error downloading file: ${error.message}`);
                    return false;
                }
            };

            // Updated downloadFiles function
            const downloadFiles = async (type) => {
                const files = fileData[type] || [];
                if (files.length === 0) {
                    alert(`No ${type} files found!`);
                    return;
                }

                // For single files, download directly
                if (files.length === 1) {
                    const file = files[0];
                    await downloadFile(file.path, file.filename);
                    return;
                }

                // For multiple files, create a zip
                try {
                    const JSZip = window.JSZip;
                    const zip = new JSZip();
                    const folder = zip.folder(type);
                    let fileCount = 0;

                    // Add each file to the zip
                    for (const file of files) {
                        try {
                            const response = await fetch(file.path);
                            if (!response.ok) {
                                console.error(`Failed to fetch ${file.path}: ${response.status}`);
                                continue;
                            }
                            
                            const blob = await response.blob();
                            folder.file(file.filename, blob);
                            fileCount++;
                        } catch (error) {
                            console.error(`Error processing ${file.filename}:`, error);
                        }
                    }

                    if (fileCount === 0) {
                        throw new Error('No files were added to the zip');
                    }

                    // Generate the zip file
                    const content = await zip.generateAsync({ type: 'blob' });
                    const url = window.URL.createObjectURL(content);
                    
                    // Create and trigger download
                    const link = document.createElement('a');
                    link.href = url;
                    link.setAttribute('download', `${type}_${new Date().toISOString().split('T')[0]}.zip`);
                    document.body.appendChild(link);
                    link.click();
                    
                    // Clean up
                    link.parentNode.removeChild(link);
                    window.URL.revokeObjectURL(url);

                    alert(`Successfully downloaded ${fileCount} ${type} file(s)`);
                } catch (error) {
                    console.error(`Error downloading ${type} files:`, error);
                    alert(`Error downloading ${type} files: ${error.message}`);
                }
            };

            if (loading) {
                return (
                    <div className="min-h-screen gradient-bg flex items-center justify-center">
                        <div className="text-white text-center">
                            <div className="animate-spin rounded-full h-16 w-16 border-b-2 border-white mx-auto mb-4"></div>
                            <p className="text-xl">Loading analysis...</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen bg-gray-50">
                    {/* Header */}
                    <div className="gradient-bg text-white p-8">
                        <div className="max-w-7xl mx-auto">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h1 className="text-4xl font-bold mb-2">Our Analysis</h1>
                                    <p className="text-lg opacity-90">Discovering the patterns in our beautiful journey together.</p>
                                    <p className="text-sm opacity-75 mt-2">Last updated: {lastUpdated}</p>
                                </div>
                                <div className="flex space-x-4">
                                    <button
                                        onClick={refreshData}
                                        className="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg font-semibold transition-colors flex items-center space-x-2"
                                    >
                                        <span>🔄</span>
                                        <span>Refresh</span>
                                    </button>
                                    <button
                                        onClick={() => window.location.href = 'index.html'}
                                        className="bg-purple-600 hover:bg-purple-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors flex items-center space-x-2"
                                    >
                                        <span>←</span>
                                        <span>Back to Main</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Navigation Tabs */}
                    <div className="bg-white shadow-sm">
                        <div className="max-w-7xl mx-auto">
                            <div className="flex space-x-1 p-4">
                                {[
                                    { id: 'overview', name: 'Overview', icon: '📊' },
                                    { id: 'messages', name: 'Messages', icon: '💬' },
                                    { id: 'emotions', name: 'Emotions', icon: '❤️' },
                                    { id: 'timeline', name: 'Timeline', icon: '📅' },
                                    { id: 'downloads', name: 'Downloads', icon: '📁' }
                                ].map(tab => (
                                    <button
                                        key={tab.id}
                                        onClick={() => setActiveTab(tab.id)}
                                        className={`px-6 py-3 rounded-lg font-semibold transition-all flex items-center space-x-2 ${
                                            activeTab === tab.id ? 'tab-active' : 'text-gray-600 hover:bg-gray-100'
                                        }`}
                                    >
                                        <span>{tab.icon}</span>
                                        <span>{tab.name}</span>
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* Content */}
                    <div className="max-w-7xl mx-auto p-8">
                        {activeTab === 'overview' && <OverviewTab chatData={chatData} chartRef={chartRef} />}
                        {activeTab === 'messages' && <MessagesTab chatData={chatData} />}
                        {activeTab === 'emotions' && <EmotionsTab chatData={chatData} />}
                        {activeTab === 'timeline' && <TimelineTab chatData={chatData} />}
                        {activeTab === 'downloads' && <DownloadsTab fileData={fileData} onDownload={downloadFiles} />}
                    </div>
                </div>
            );
        };

        const OverviewTab = ({ chatData, chartRef }) => (
            <div className="space-y-8">
                {/* Statistics Cards */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                    <div className="bg-white rounded-xl p-6 card-shadow">
                        <div className="text-3xl font-bold text-purple-600 mb-2">{chatData?.totalMessages || 0}</div>
                        <div className="text-gray-600">Total Messages</div>
                    </div>
                    <div className="bg-white rounded-xl p-6 card-shadow">
                        <div className="text-3xl font-bold text-purple-600 mb-2">{chatData?.totalDays || 0}</div>
                        <div className="text-gray-600">Days Together</div>
                    </div>
                    <div className="bg-white rounded-xl p-6 card-shadow">
                        <div className="text-3xl font-bold text-purple-600 mb-2">{chatData?.averageMessagesPerDay?.toFixed(1) || 0}</div>
                        <div className="text-gray-600">Messages/Day</div>
                    </div>
                </div>

                {/* Platform Breakdown */}
                {chatData?.breakdown && (
                    <div className="bg-white rounded-xl p-6 card-shadow">
                        <h3 className="text-xl font-bold text-gray-800 mb-4">Platform Breakdown</h3>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            {chatData.breakdown.instagram && (
                                <div className="bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg p-4">
                                    <div className="flex items-center mb-3">
                                        <span className="text-2xl mr-2">📱</span>
                                        <h4 className="font-semibold text-gray-800">Instagram</h4>
                                    </div>
                                    <div className="space-y-2 text-sm">
                                        <div className="flex justify-between">
                                            <span>Messages:</span>
                                            <span className="font-semibold">{chatData.breakdown.instagram.totalMessages}</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span>Days:</span>
                                            <span className="font-semibold">{chatData.breakdown.instagram.totalDays}</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span>Avg/Day:</span>
                                            <span className="font-semibold">{chatData.breakdown.instagram.averageMessagesPerDay?.toFixed(1)}</span>
                                        </div>
                                    </div>
                                </div>
                            )}
                            {chatData.breakdown.whatsapp && (
                                <div className="bg-gradient-to-r from-green-50 to-teal-50 rounded-lg p-4">
                                    <div className="flex items-center mb-3">
                                        <span className="text-2xl mr-2">💬</span>
                                        <h4 className="font-semibold text-gray-800">WhatsApp</h4>
                                    </div>
                                    <div className="space-y-2 text-sm">
                                        <div className="flex justify-between">
                                            <span>Messages:</span>
                                            <span className="font-semibold">{chatData.breakdown.whatsapp.totalMessages}</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span>Days:</span>
                                            <span className="font-semibold">{chatData.breakdown.whatsapp.totalDays}</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span>Avg/Day:</span>
                                            <span className="font-semibold">{chatData.breakdown.whatsapp.averageMessagesPerDay?.toFixed(1)}</span>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                )}

                {/* Additional Statistics */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                    <div className="bg-white rounded-xl p-6 card-shadow">
                        <div className="text-3xl font-bold text-purple-600 mb-2">{chatData?.responseTime?.Average || '0 minutes'}</div>
                        <div className="text-gray-600">Avg Response Time</div>
                    </div>
                </div>

                {/* Chart */}
                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6 text-center">Message Types Distribution</h3>
                    <div className="h-96">
                        <canvas ref={chartRef}></canvas>
                    </div>
                </div>
            </div>
        );

        const MessagesTab = ({ chatData }) => (
            <div className="space-y-8">
                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Message Analysis</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <h4 className="text-lg font-semibold text-gray-700 mb-4">Message Types</h4>
                            <div className="space-y-3">
                                {Object.entries(chatData?.messageTypes || {}).map(([type, count]) => (
                                    <div key={type} className="flex justify-between items-center">
                                        <span className="text-gray-600">{type}</span>
                                        <span className="font-semibold text-purple-600">{count}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                        <div>
                            <h4 className="text-lg font-semibold text-gray-700 mb-4">Response Times</h4>
                            <div className="space-y-3">
                                {Object.entries(chatData?.responseTime || {}).map(([type, time]) => (
                                    <div key={type} className="flex justify-between items-center">
                                        <span className="text-gray-600">{type}</span>
                                        <span className="font-semibold text-purple-600">{time}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        );

        const EmotionsTab = ({ chatData }) => (
            <div className="space-y-8">
                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Sentiment Analysis</h3>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                        {Object.entries(chatData?.sentimentAnalysis || {}).map(([sentiment, percentage]) => (
                            <div key={sentiment} className="text-center">
                                <div className="text-4xl font-bold text-purple-600 mb-2">{percentage}%</div>
                                <div className="text-gray-600">{sentiment}</div>
                            </div>
                        ))}
                    </div>
                </div>

                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Most Used Emojis</h3>
                    <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                        {Object.entries(chatData?.emojiUsage || {})
                            .sort(([,a], [,b]) => b - a)
                            .slice(0, 12)
                            .map(([emoji, count]) => (
                                <div key={emoji} className="text-center p-4 bg-gray-50 rounded-lg">
                                    <div className="text-3xl mb-2">{emoji}</div>
                                    <div className="text-sm text-gray-600">{count}</div>
                                </div>
                            ))}
                    </div>
                </div>
            </div>
        );

        const TimelineTab = ({ chatData }) => (
            <div className="space-y-8">
                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Special Moments</h3>
                    <div className="space-y-4">
                        {chatData?.specialMoments?.map((moment, index) => (
                            <div key={index} className="border-l-4 border-purple-500 pl-6 py-4">
                                <div className="font-semibold text-gray-800">{moment.event}</div>
                                <div className="text-sm text-gray-500">{moment.date}</div>
                                <div className="text-gray-600 mt-1">{moment.significance}</div>
                            </div>
                        ))}
                    </div>
                </div>

                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Conversation Topics</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        {Object.entries(chatData?.conversationTopics || {}).map(([topic, percentage]) => (
                            <div key={topic} className="flex justify-between items-center p-4 bg-gray-50 rounded-lg">
                                <span className="text-gray-700">{topic}</span>
                                <span className="font-semibold text-purple-600">{percentage}%</span>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        );

        const DownloadsTab = ({ fileData, onDownload }) => (
            <div className="space-y-8">
                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Download Your Memories</h3>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div className="text-center p-6 bg-pink-50 rounded-lg">
                            <div className="text-4xl mb-4">📸</div>
                            <h4 className="text-lg font-semibold text-gray-800 mb-2">Photos</h4>
                            <p className="text-gray-600 mb-4">{fileData.photos.length} files</p>
                            <button
                                onClick={() => onDownload('photos')}
                                className="bg-pink-500 hover:bg-pink-600 text-white px-6 py-2 rounded-lg font-semibold transition-colors"
                            >
                                Download Photos
                            </button>
                        </div>
                        <div className="text-center p-6 bg-blue-50 rounded-lg">
                            <div className="text-4xl mb-4">🎵</div>
                            <h4 className="text-lg font-semibold text-gray-800 mb-2">Audio</h4>
                            <p className="text-gray-600 mb-4">{fileData.audio.length} files</p>
                            <button
                                onClick={() => onDownload('audio')}
                                className="bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg font-semibold transition-colors"
                            >
                                Download Audio
                            </button>
                        </div>
                        <div className="text-center p-6 bg-green-50 rounded-lg">
                            <div className="text-4xl mb-4">🎬</div>
                            <h4 className="text-lg font-semibold text-gray-800 mb-2">Videos</h4>
                            <p className="text-gray-600 mb-4">{fileData.videos.length} files</p>
                            <button
                                onClick={() => onDownload('videos')}
                                className="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg font-semibold transition-colors"
                            >
                                Download Videos
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        );

        ReactDOM.render(<App />, document.getElementById('app'));
    </script>
</body>
</html>
