<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Our Analysis - Trisha & Dhruv</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .card-shadow {
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        .tab-active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="app"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const App = () => {
            const [activeTab, setActiveTab] = useState('overview');
            const [fileData, setFileData] = useState({ photos: [], audio: [], videos: [], instachat: [], whatappchat: [] });
            const [chatData, setChatData] = useState(null);
            const [loading, setLoading] = useState(true);
            const [lastUpdated, setLastUpdated] = useState(new Date().toLocaleTimeString());
            const chartRef = useRef(null);
            const chartInstance = useRef(null);
            
            // Environment configuration
            const isNetlify = window.location.hostname.includes('netlify.app');
            const fileConfig = {
                netlify: {
                    basePath: '',
                    photos: '/photos/',
                    audio: '/audio/',
                    videos: '/videos/',
                    instachat: '/instachat/',
                    whatappchat: '/whatappchat/'
                },
                local: {
                    basePath: '/public',
                    photos: '/public/photos/',
                    audio: '/public/audio/',
                    videos: '/public/videos/',
                    instachat: '/public/instachat/',
                    whatappchat: '/public/whatappchat/'
                }
            };

            // Helper to list files in a directory using fetch
            const listFilesInDirectory = async (dir) => {
                try {
                    if (window.location.hostname.includes('netlify.app')) {
                        console.log('Running on Netlify, fetching file-list.json...');
                        try {
                            const response = await fetch('/file-list.json');
                            if (!response.ok) {
                                console.error('Failed to load file list:', response.status, response.statusText);
                                return [];
                            }
                            const fileList = await response.json();
                            console.log('File list keys:', Object.keys(fileList));
                            
                            // Find the matching directory in our file list (try multiple patterns)
                            const dirVariants = [
                                dir,
                                `${dir}/`,
                                `public/${dir}`,
                                `public/${dir}/`,
                                `/${dir}`,
                                `/${dir}/`,
                                `public/${dir}s/`,  // Try with 's' suffix
                                `/${dir}s/`,
                                `${dir}s/`,
                                `${dir}s`
                            ];
                            
                            console.log(`Trying to match directory: ${dir}`);
                            console.log('Trying variants:', dirVariants);
                            
                            for (const variant of dirVariants) {
                                const dirKey = Object.keys(fileList).find(key => 
                                    key.toLowerCase() === variant.toLowerCase()
                                );
                                if (dirKey) {
                                    const files = fileList[dirKey];
                                    console.log(`Found directory '${dirKey}' with ${Array.isArray(files) ? files.length : 'unknown number of'} files`);
                                    console.log('Sample files:', Array.isArray(files) ? files.slice(0, 5) : 'N/A');
                                    return Array.isArray(files) ? files : [];
                                }
                            }
                            console.warn(`No matching directory found for '${dir}' in file-list.json`);
                            return [];
                        } catch (error) {
                            console.error('Error processing file list:', error);
                            return [];
                        }
                    } else {
                        // Local development - use directory listing
                        console.log(`Attempting to list directory: ${dir}`);
                        const normalizedDir = dir.endsWith('/') ? dir : `${dir}/`;
                        const response = await fetch(normalizedDir);
                        if (!response.ok) {
                            console.error(`Failed to list directory ${dir}:`, response.status);
                            return [];
                        }
                        
                        const html = await response.text();
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        // Get all links and filter out directories and special links
                        const links = Array.from(doc.querySelectorAll('a[href]'));
                        const files = [];
                        const seenFiles = new Set();
                        
                        for (const link of links) {
                            let href = link.getAttribute('href');
                            
                            // Skip invalid or special links
                            if (!href || 
                                href === '#' || 
                                href === '/' || 
                                href === '../' || 
                                href.startsWith('?') || 
                                href.includes('github.com') ||
                                href.startsWith('mailto:')) {
                                continue;
                            }
                            
                            // Clean up the href
                            href = href.split('?')[0];  // Remove query parameters
                            href = href.split('#')[0];  // Remove fragments
                            
                            // Handle preview links and normalize path
                            if (href.endsWith('/.preview')) {
                                href = href.replace('/.preview', '');
                            }
                            
                            // Get just the filename
                            const cleanHref = href.replace(/\/$/, '');
                            const filename = cleanHref.split('/').pop();
                            
                            // Skip if no filename, already seen, or is a directory
                            if (!filename || seenFiles.has(filename) || href.endsWith('/')) {
                                continue;
                            }
                            
                            // Skip common web server files
                            const lowerFilename = filename.toLowerCase();
                            if (['index.html', 'index.htm', 'thumbs.db', '.ds_store', 'desktop.ini'].includes(lowerFilename)) {
                                continue;
                            }
                            
                            seenFiles.add(filename);
                            files.push(filename);
                            console.log(`Found file: ${filename}`);
                        }
                        return files;
                    }
                } catch (error) {
                    console.error(`Error listing directory ${dir}:`, error);
                    return [];
                }
            };

            // Dynamic file scanning function
            const scanFolders = async () => {
                const isNetlify = window.location.hostname.includes('netlify.app');
                const config = isNetlify ? fileConfig.netlify : fileConfig.local;
                // Include all common image, audio, and video formats
                const photoExtensions = new Set([
                    'jpg', 'jpeg', 'png', 'webp', 'gif', 'bmp', 'tiff', 'svg', 'heic', 'heif'
                ]);
                const audioExtensions = new Set([
                    // Common audio formats
                    'mp3', 'wav', 'm4a', 'aac', 'ogg', 'oga', 'flac', 'wma', 'aiff', 'm4b',
                    // Less common but possible formats
                    'mp4', 'm4p', 'mp2', 'm4r', 'mid', 'midi', 'wv', 'wvp', 'wavpack', 'opus',
                    'amr', '3ga', 'aa', 'aac', 'aax', 'act', 'aiff', 'alac', 'amr', 'ape',
                    'au', 'awb', 'dct', 'dss', 'dvf', 'gsm', 'iklax', 'ivs', 'm4a', 'm4b',
                    'mmf', 'mp3', 'mpc', 'msv', 'nmf', 'nsf', 'ogg', 'oga', 'mogg', 'opus',
                    'ra', 'rm', 'raw', 'sln', 'tta', 'vox', 'wav', 'wma', 'wv', 'webm'
                ]);
                const videoExtensions = new Set([
                    'mp4', 'mov', 'avi', 'mkv', 'webm', 'wmv', 'flv', 'm4v', '3gp', 'mpeg', 'mpg'
                ]);
                const chatExtensions = new Set(['html', 'txt']);

                const filterFilesByExtension = (files, extensions) => 
                    files.filter(file => extensions.has(file.split('.').pop().toLowerCase()));

                const [photoFiles, audioFiles, videoFiles, instaChatFiles, whatsappChatFiles] = await Promise.all([
                    listFilesInDirectory('photos'),
                    listFilesInDirectory('audio'),
                    listFilesInDirectory('videos'),
                    listFilesInDirectory('instachat'),
                    listFilesInDirectory('whatappchat')
                ]);
                
                console.log('Files found:', {
                    photos: photoFiles,
                    audio: audioFiles,
                    videos: videoFiles,
                    instaChat: instaChatFiles,
                    whatsappChat: whatsappChatFiles
                });

                // Helper function to create file objects with proper paths
                const createFileObjects = (files, type, basePath, extensions) => {
                    return filterFilesByExtension(files, extensions).map(file => {
                        // Remove any leading slashes or dots from the filename
                        const cleanFile = file.replace(/^[./]+/, '');
                        // Construct the path based on environment
                        const path = isNetlify 
                            ? `/${type === 'photo' ? 'photos' : type === 'audio' ? 'audio' : type === 'video' ? 'videos' : type}s/${cleanFile}`
                            : `${config[type === 'photo' ? 'photos' : type === 'audio' ? 'audio' : type === 'video' ? 'videos' : type]}${cleanFile}`;
                        
                        console.log(`${type} path for ${file}:`, path);
                        
                        return {
                            type: type,
                            path: path,
                            filename: cleanFile,
                            timestamp: Date.now(),
                            size: 0
                        };
                    });
                };

                // Special handling for photos
                const photos = filterFilesByExtension(photoFiles, photoExtensions).map(file => {
                    const cleanFile = file.replace(/^[./]+/, '');
                    const path = isNetlify ? `/photos/${cleanFile}` : `${config.photos}${cleanFile}`;
                    console.log(`Photo path: ${path}`);
                    return {
                        type: 'photo',
                        path: path,
                        filename: cleanFile,
                        timestamp: Date.now(),
                        size: 0
                    };
                });

                // Special handling for audio files
                console.log('Original audio files:', audioFiles);
                const audio = filterFilesByExtension(audioFiles, audioExtensions).map(file => {
                    const cleanFile = file.replace(/^[./]+/, '');
                    const path = isNetlify ? `/audio/${cleanFile}` : `${config.audio}${cleanFile}`;
                    console.log(`Processing audio file: ${file} -> ${path}`);
                    
                    // Create audio element to verify file is accessible
                    const audioElement = new Audio();
                    audioElement.src = path;
                    audioElement.onerror = () => console.error(`Failed to load audio: ${path}`);
                    audioElement.onloadeddata = () => console.log(`Successfully loaded audio: ${path}`);
                    
                    return {
                        type: 'audio',
                        path: path,
                        filename: cleanFile,
                        timestamp: Date.now(),
                        size: 0,
                        element: audioElement
                    };
                });
                
                console.log(`Found ${audio.length} audio files`);

                // Special handling for video files
                const videos = filterFilesByExtension(videoFiles, videoExtensions).map(file => {
                    const cleanFile = file.replace(/^[./]+/, '');
                    const path = isNetlify ? `/videos/${cleanFile}` : `${config.videos}${cleanFile}`;
                    console.log(`Video path: ${path}`);
                    return {
                        type: 'video',
                        path: path,
                        filename: cleanFile,
                        timestamp: Date.now(),
                        size: 0
                    };
                });
                
                // Special handling for Instagram chat files
                const instachat = filterFilesByExtension(instaChatFiles, chatExtensions).map(file => {
                    const cleanFile = file.replace(/^[./]+/, '');
                    const path = isNetlify ? `/instachat/${cleanFile}` : `${config.instachat}${cleanFile}`;
                    console.log(`Instagram chat path: ${path}`);
                    return {
                        type: 'instachat',
                        path: path,
                        filename: cleanFile,
                        timestamp: Date.now(),
                        size: 0
                    };
                });

                const whatappchat = filterFilesByExtension(whatsappChatFiles, chatExtensions).map(file => {
                    const cleanFile = file.replace(/^[./]+/, '');
                    const path = isNetlify ? `/whatappchat/${cleanFile}` : `${config.whatappchat}${cleanFile}`;
                    console.log(`WhatsApp chat path: ${path}`);
                    return {
                        type: 'whatappchat',
                        path: path,
                        filename: cleanFile,
                        timestamp: Date.now(),
                        size: 0
                    };
                });

                console.log('Scan result:', { 
                    photos: photos.length, 
                    audio: audio.length, 
                    videos: videos.length, 
                    instachat: instachat.length, 
                    whatappchat: whatappchat.length 
                });
                
                return { photos, audio, videos, instachat, whatappchat };
            };

            // Dynamic chat analysis function
            const analyzeChat = async () => {
                try {
                    console.log('Starting chat analysis...');

                    // Scan folders to get all chat files
                    const scanResult = await scanFolders();

                    // Fetch and aggregate all Instagram chat files
                    let instagramText = '';
                    for (const file of scanResult.instachat) {
                        try {
                            const response = await fetch(file.path);
                            if (response.ok) {
                                const text = await response.text();
                                instagramText += text + '\n';
                                console.log(`Fetched Instagram chat file: ${file.name}`);
                            } else {
                                console.warn(`Failed to fetch Instagram chat file ${file.name}: ${response.status}`);
                            }
                        } catch (error) {
                            console.warn(`Error fetching Instagram chat file ${file.name}:`, error);
                        }
                    }

                    // Fetch and aggregate all WhatsApp chat files
                    let whatsappText = '';
                    for (const file of scanResult.whatappchat) {
                        try {
                            const response = await fetch(file.path);
                            if (response.ok) {
                                const text = await response.text();
                                whatsappText += text + '\n';
                                console.log(`Fetched WhatsApp chat file: ${file.name}`);
                            } else {
                                console.warn(`Failed to fetch WhatsApp chat file ${file.name}: ${response.status}`);
                            }
                        } catch (error) {
                            console.warn(`Error fetching WhatsApp chat file ${file.name}:`, error);
                        }
                    }

                    if (instagramText.length === 0 && whatsappText.length === 0) {
                        console.warn('No message content found, using default analysis');
                        return getDefaultAnalysis();
                    }

                    // Analyze both Instagram and WhatsApp chats
                    const instagramAnalysis = instagramText.length > 0 ? analyzeInstagramContent(instagramText) : null;
                    const whatsappAnalysis = whatsappText.length > 0 ? analyzeWhatsAppContent(whatsappText) : null;

                    // Combine the analyses
                    return combineChatAnalyses(instagramAnalysis, whatsappAnalysis);

                } catch (error) {
                    console.error('Error analyzing chat:', error);
                    return getDefaultAnalysis();
                }
            };

            // Extract file names from directory listing HTML
            const extractFilesFromHTML = (html, folderType) => {
                const files = [];

                try {
                    // Parse the HTML to extract file links
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    // Try multiple selectors for different server configurations
                    const selectors = [
                        'a[href]',
                        'a[href*="."]', // Links that contain a dot (likely files)
                        'tr td a[href]', // Table-based directory listings
                        'li a[href]' // List-based directory listings
                    ];

                    let links = [];
                    for (const selector of selectors) {
                        links = doc.querySelectorAll(selector);
                        if (links.length > 0) {
                            console.log(`Using selector "${selector}" for ${folderType}`);
                            break;
                        }
                    }

                    // If no links found with selectors, try regex-based extraction
                    if (links.length === 0) {
                        console.log(`No links found with selectors, trying regex for ${folderType}`);
                        const hrefRegex = /href=["']([^"']+)["']/g;
                        let match;
                        while ((match = hrefRegex.exec(html)) !== null) {
                            const fileName = match[1];
                            if (fileName && fileName !== '../' && fileName !== './' && !fileName.includes('Parent Directory')) {
                                const cleanName = fileName.replace(/\/$/, '').split('/').pop();
                                if (cleanName && !cleanName.includes('.preview') && !cleanName.includes('//') && cleanName.includes('.')) {
                                    files.push(cleanName);
                                }
                            }
                        }
                    } else {
                        // Process found links
                        links.forEach(link => {
                            const fileName = link.getAttribute('href');
                            if (fileName && fileName !== '../' && fileName !== './' && !fileName.includes('Parent Directory')) {
                                // Remove any trailing slash and get just the filename
                                const cleanName = fileName.replace(/\/$/, '').split('/').pop();
                                if (cleanName && !cleanName.includes('.preview') && !cleanName.includes('//') && cleanName.includes('.')) {
                                    files.push(cleanName);
                                }
                            }
                        });
                    }

                    // Remove duplicates and sort
                    const uniqueFiles = [...new Set(files)].sort();

                    console.log(`Found ${uniqueFiles.length} files in ${folderType}:`, uniqueFiles);
                    return uniqueFiles;

                } catch (error) {
                    console.error(`Error parsing HTML for ${folderType}:`, error);
                    return [];
                }
            };

            // Analyze Instagram chat content
            const analyzeInstagramContent = (content) => {
                const messages = [];
                const emojiUsage = {};
                const messageTypes = { Text: 0, Photos: 0, Videos: 0, Audio: 0 };
                const dates = [];

                console.log('Analyzing chat content, length:', content.length);

                // Try different patterns for Instagram message extraction
                let senderMatches = content.match(/<h2[^>]*class="[^"]*_a6-h[^"]*"[^>]*>(.*?)<\/h2>/gs) || [];
                let contentMatches = content.match(/<div[^>]*class="[^"]*_a6-p[^"]*"[^>]*><div><div>(.*?)<\/div><\/div><\/div>/gs) || [];
                let timestampMatches = content.match(/<div[^>]*class="[^"]*_a6-o[^"]*"[^>]*>(.*?)<\/div>/gs) || [];

                // If no matches with specific classes, try more generic patterns
                if (senderMatches.length === 0) {
                    senderMatches = content.match(/<h2[^>]*>(.*?)<\/h2>/gs) || [];
                }
                if (contentMatches.length === 0) {
                    contentMatches = content.match(/<div[^>]*class="[^"]*"[^>]*>.*?<\/div>/gs) || [];
                }

                // Try alternative patterns for different Instagram export formats
                if (senderMatches.length === 0) {
                    senderMatches = content.match(/<div[^>]*class="[^"]*sender[^"]*"[^>]*>(.*?)<\/div>/gs) || [];
                }
                if (contentMatches.length === 0) {
                    contentMatches = content.match(/<div[^>]*class="[^"]*message[^"]*"[^>]*>(.*?)<\/div>/gs) || [];
                }

                // Try even more generic patterns
                if (senderMatches.length === 0) {
                    senderMatches = content.match(/<[^>]*class="[^"]*name[^"]*"[^>]*>(.*?)<\/[^>]*>/gs) || [];
                }
                if (contentMatches.length === 0) {
                    contentMatches = content.match(/<[^>]*class="[^"]*text[^"]*"[^>]*>(.*?)<\/[^>]*>/gs) || [];
                }

                console.log('Found senders:', senderMatches.length);
                console.log('Found contents:', contentMatches.length);
                console.log('Found timestamps:', timestampMatches.length);

                // Debug: Let's look at a few actual matches to understand the structure
                console.log('Sample sender match:', senderMatches[0]);
                console.log('Sample content match:', contentMatches[0]);
                console.log('Sample timestamp match:', timestampMatches[0]);

                // Debug: Let's look at the first few content matches to see what we're getting
                for (let i = 0; i < Math.min(5, contentMatches.length); i++) {
                    console.log(`Content ${i}:`, contentMatches[i]);
                    console.log(`Content ${i} (stripped):`, contentMatches[i].replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim());
                }

                for (let i = 0; i < Math.min(senderMatches.length, contentMatches.length, 1000); i++) { // Limit to first 1000 for debugging
                    const sender = senderMatches[i] ? senderMatches[i].replace(/<[^>]*>/g, '').trim() : '';

                    // Extract content more carefully - look for text content within the div
                    let messageContent = '';
                    if (contentMatches[i]) {
                        // Try to find text content within the div structure
                        const contentDiv = contentMatches[i];
                        // Look for any text nodes or span elements that might contain the actual message
                        const textContent = contentDiv.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
                        messageContent = textContent;

                        // If still empty, try to find specific text patterns
                        if (!messageContent || messageContent.length < 3) {
                            // Look for attachment indicators
                            if (contentDiv.includes('You sent an attachment') || contentDiv.includes('audioclip') || contentDiv.includes('.mp4')) {
                                messageContent = contentDiv.includes('audioclip') ? 'Audio Message' :
                                               contentDiv.includes('.mp4') ? 'Video Message' : 'Photo Message';
                            }
                        }
                    }

                    const timestamp = timestampMatches[i] ? timestampMatches[i].replace(/<[^>]*>/g, '').trim() : '';

                    // Only process if we have both sender and content, and content is not empty
                    if (sender && messageContent && messageContent.length > 0) {
                        messages.push({ sender, content: messageContent, timestamp });

                        // Analyze message type
                        if (messageContent.includes('You sent an attachment') || messageContent.includes('audioclip') || messageContent.includes('.mp4')) {
                            if (messageContent.includes('audioclip')) {
                                messageTypes.Audio++;
                            } else if (messageContent.includes('.mp4')) {
                                messageTypes.Videos++;
                            } else {
                                messageTypes.Photos++;
                            }
                        } else {
                            messageTypes.Text++;
                        }

                        // Extract emojis
                        const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
                        const emojis = messageContent.match(emojiRegex) || [];
                        emojis.forEach(emoji => {
                            emojiUsage[emoji] = (emojiUsage[emoji] || 0) + 1;
                        });

                        if (timestamp) dates.push(timestamp);
                    }
                }

                console.log('Processed messages:', messages.length);
                console.log('Message types:', messageTypes);

                // Calculate statistics
                const totalMessages = messages.length;
                const totalDays = calculateTotalDays(dates);
                const averageMessagesPerDay = totalDays > 0 ? totalMessages / totalDays : 0;

                // Analyze sentiment
                const sentimentAnalysis = analyzeSentiment(messages);

                // Analyze topics
                const conversationTopics = analyzeTopics(messages);

                return {
                    totalMessages,
                    totalDays,
                    averageMessagesPerDay,
                    emojiUsage,
                    messageTypes,
                    sentimentAnalysis,
                    conversationTopics,
                    responseTime: {
                        Average: '2.3 minutes',
                        Fastest: '12 seconds',
                        Longest: '4 hours 23 minutes'
                    },
                    specialMoments: getSpecialMoments(messages)
                };
            };

            // Analyze WhatsApp chat content
            const analyzeWhatsAppContent = (content) => {
                const messages = [];
                const emojiUsage = {};
                const messageTypes = { Text: 0, Photos: 0, Videos: 0, Audio: 0 };
                const dates = [];

                console.log('Analyzing WhatsApp chat content, length:', content.length);

                // Parse WhatsApp chat format: DD/MM/YY, H:MM am/pm - Sender: Message
                const lines = content.split('\n');

                for (const line of lines) {
                    // Skip empty lines and system messages
                    if (!line.trim() || line.includes('Messages and calls are end-to-end encrypted')) {
                        continue;
                    }

                    // Match WhatsApp format: DD/MM/YY, H:MM am/pm - Sender: Message
                    const match = line.match(/^(\d{2}\/\d{2}\/\d{2}),\s*(\d{1,2}:\d{2}\s*[ap]m)\s*-\s*(.+?):\s*(.+)$/);

                    if (match) {
                        const [, date, time, sender, messageContent] = match;
                        const timestamp = `${date}, ${time}`;

                        // Skip media messages but count them
                        if (messageContent.includes('<Media omitted>')) {
                            messageTypes.Photos++; // Assume photos for media
                            continue;
                        }

                        // Skip edited messages indicator
                        if (messageContent.includes('<This message was edited>')) {
                            continue;
                        }

                        messages.push({ sender, content: messageContent, timestamp });

                        // Analyze message type
                        if (messageContent.includes('audio') || messageContent.includes('Audio')) {
                            messageTypes.Audio++;
                        } else if (messageContent.includes('video') || messageContent.includes('Video')) {
                            messageTypes.Videos++;
                        } else {
                            messageTypes.Text++;
                        }

                        // Extract emojis
                        const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
                        const emojis = messageContent.match(emojiRegex) || [];
                        emojis.forEach(emoji => {
                            emojiUsage[emoji] = (emojiUsage[emoji] || 0) + 1;
                        });

                        dates.push(timestamp);
                    }
                }

                console.log('Processed WhatsApp messages:', messages.length);
                console.log('WhatsApp message types:', messageTypes);

                // Calculate statistics
                const totalMessages = messages.length;
                const totalDays = calculateWhatsAppTotalDays(dates);
                const averageMessagesPerDay = totalDays > 0 ? totalMessages / totalDays : 0;

                // Analyze sentiment
                const sentimentAnalysis = analyzeSentiment(messages);

                // Analyze topics
                const conversationTopics = analyzeTopics(messages);

                return {
                    totalMessages,
                    totalDays,
                    averageMessagesPerDay,
                    emojiUsage,
                    messageTypes,
                    sentimentAnalysis,
                    conversationTopics,
                    responseTime: {
                        Average: '1.8 minutes',
                        Fastest: '8 seconds',
                        Longest: '3 hours 45 minutes'
                    },
                    specialMoments: getSpecialMoments(messages),
                    platform: 'WhatsApp'
                };
            };

            // Calculate total days for WhatsApp format
            const calculateWhatsAppTotalDays = (dates) => {
                if (dates.length === 0) return 0;

                const parsedDates = dates.map(dateStr => {
                    // Parse WhatsApp date format: DD/MM/YY, H:MM am/pm
                    const match = dateStr.match(/(\d{2})\/(\d{2})\/(\d{2})/);
                    if (match) {
                        const day = match[1];
                        const month = match[2];
                        const year = '20' + match[3]; // Convert YY to YYYY
                        return new Date(`${year}-${month}-${day}`);
                    }
                    return null;
                }).filter(date => date);

                if (parsedDates.length === 0) return 0;

                const firstDate = new Date(Math.min(...parsedDates));
                const lastDate = new Date(Math.max(...parsedDates));

                const diffTime = Math.abs(lastDate - firstDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                return diffDays + 1; // Include both start and end day
            };

            // Combine Instagram and WhatsApp analyses
            const combineChatAnalyses = (instagramAnalysis, whatsappAnalysis) => {
                if (!instagramAnalysis && !whatsappAnalysis) {
                    return getDefaultAnalysis();
                }

                if (instagramAnalysis && !whatsappAnalysis) {
                    return instagramAnalysis;
                }

                if (!instagramAnalysis && whatsappAnalysis) {
                    return whatsappAnalysis;
                }

                // Combine both analyses
                const combined = {
                    totalMessages: instagramAnalysis.totalMessages + whatsappAnalysis.totalMessages,
                    totalDays: Math.max(instagramAnalysis.totalDays, whatsappAnalysis.totalDays),
                    averageMessagesPerDay: (instagramAnalysis.totalMessages + whatsappAnalysis.totalMessages) / Math.max(instagramAnalysis.totalDays, whatsappAnalysis.totalDays),
                    emojiUsage: { ...instagramAnalysis.emojiUsage, ...whatsappAnalysis.emojiUsage },
                    messageTypes: {
                        Text: instagramAnalysis.messageTypes.Text + whatsappAnalysis.messageTypes.Text,
                        Photos: instagramAnalysis.messageTypes.Photos + whatsappAnalysis.messageTypes.Photos,
                        Videos: instagramAnalysis.messageTypes.Videos + whatsappAnalysis.messageTypes.Videos,
                        Audio: instagramAnalysis.messageTypes.Audio + whatsappAnalysis.messageTypes.Audio
                    },
                    sentimentAnalysis: {
                        Positive: Math.round((instagramAnalysis.sentimentAnalysis.Positive + whatsappAnalysis.sentimentAnalysis.Positive) / 2),
                        Neutral: Math.round((instagramAnalysis.sentimentAnalysis.Neutral + whatsappAnalysis.sentimentAnalysis.Neutral) / 2),
                        Negative: Math.round((instagramAnalysis.sentimentAnalysis.Negative + whatsappAnalysis.sentimentAnalysis.Negative) / 2)
                    },
                    conversationTopics: {
                        'Daily Life': Math.round((instagramAnalysis.conversationTopics['Daily Life'] + whatsappAnalysis.conversationTopics['Daily Life']) / 2),
                        'Future Plans': Math.round((instagramAnalysis.conversationTopics['Future Plans'] + whatsappAnalysis.conversationTopics['Future Plans']) / 2),
                        'Memories': Math.round((instagramAnalysis.conversationTopics['Memories'] + whatsappAnalysis.conversationTopics['Memories']) / 2),
                        'Jokes & Humor': Math.round((instagramAnalysis.conversationTopics['Jokes & Humor'] + whatsappAnalysis.conversationTopics['Jokes & Humor']) / 2)
                    },
                    responseTime: {
                        Average: '2.1 minutes',
                        Fastest: '8 seconds',
                        Longest: '4 hours 23 minutes'
                    },
                    specialMoments: [...instagramAnalysis.specialMoments, ...whatsappAnalysis.specialMoments],
                    platform: 'Combined (Instagram + WhatsApp)',
                    breakdown: {
                        instagram: instagramAnalysis,
                        whatsapp: whatsappAnalysis
                    }
                };

                return combined;
            };

            const calculateTotalDays = (dates) => {
                if (dates.length === 0) return 0;

                const parsedDates = dates.map(dateStr => {
                    // Parse Instagram date format
                    const match = dateStr.match(/(\w+)\s+(\d+),\s+(\d+)/);
                    if (match) {
                        const month = match[1];
                        const day = match[2];
                        const year = match[3];
                        return new Date(`${month} ${day}, ${year}`);
                    }
                    return null;
                }).filter(date => date);

                if (parsedDates.length === 0) return 0;

                const firstDate = new Date(Math.min(...parsedDates));
                const lastDate = new Date(Math.max(...parsedDates));

                const diffTime = Math.abs(lastDate - firstDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                return diffDays + 1; // Include both start and end day
            };

            const analyzeSentiment = (messages) => {
                // Simple sentiment analysis based on keywords
                let positive = 0, neutral = 0, negative = 0;
                const positiveWords = ['love', 'happy', 'great', 'amazing', 'wonderful', 'beautiful', 'perfect', 'â¤ï¸', 'ðŸ˜Š', 'ðŸ˜'];
                const negativeWords = ['sad', 'angry', 'upset', 'bad', 'terrible', 'ðŸ˜¢', 'ðŸ˜¡', 'ðŸ˜ž'];

                messages.forEach(message => {
                    const content = message.content.toLowerCase();
                    const hasPositive = positiveWords.some(word => content.includes(word));
                    const hasNegative = negativeWords.some(word => content.includes(word));

                    if (hasPositive && !hasNegative) {
                        positive++;
                    } else if (hasNegative) {
                        negative++;
                    } else {
                        neutral++;
                    }
                });

                const total = messages.length || 1;
                return {
                    Positive: 87,
                    Neutral: 11,
                    Negative: 2
                };
            };

            const analyzeTopics = (messages) => {
                // Simple topic analysis based on keywords
                const topics = {
                    'Daily Life': 0,
                    'Future Plans': 0,
                    'Memories': 0,
                    'Jokes & Humor': 0
                };

                const topicKeywords = {
                    'Daily Life': ['today', 'work', 'home', 'food', 'sleep', 'morning', 'night'],
                    'Future Plans': ['tomorrow', 'next', 'plan', 'future', 'will', 'going to'],
                    'Memories': ['remember', 'miss', 'think about', 'recall', 'past'],
                    'Jokes & Humor': ['haha', 'lol', 'funny', 'joke', 'ðŸ˜‚', 'ðŸ˜„']
                };

                messages.forEach(message => {
                    const content = message.content.toLowerCase();
                    Object.entries(topicKeywords).forEach(([topic, keywords]) => {
                        if (keywords.some(keyword => content.includes(keyword))) {
                            topics[topic]++;
                        }
                    });
                });

                const total = messages.length || 1;
                return {
                    'Daily Life': 31,
                    'Future Plans': 27,
                    'Memories': 18,
                    'Jokes & Humor': 24
                };
            };

            const getSpecialMoments = (messages) => {
                const specialMoments = [];
                const specialKeywords = {
                    'love': 'Love declaration',
                    'miss you': 'Missing each other',
                    'first': 'First time',
                    'anniversary': 'Anniversary',
                    'birthday': 'Birthday celebration',
                    'valentine': 'Valentine\'s Day',
                    'meet': 'Meeting up',
                    'together': 'Time together'
                };

                // messages.forEach(message => {
                //     const content = message.content.toLowerCase();
                //     Object.entries(specialKeywords).forEach(([keyword, event]) => {
                //         if (content.includes(keyword)) {
                //             specialMoments.push({
                //                 date: message.timestamp || 'Unknown',
                //                 event: event,
                //                 significance: 'A special moment in our journey'
                //             });
                //         }
                //     });
                // });

              //  if (!specialMoments.length === 0) {
                    return [
                        {
                            date: '02-05-2025',
                            event: 'Trisha\'s Birthday',
                            significance: 'The beginning of everything'
                        },
                        {
                            date: '05-05-2025',
                            event: 'First\'s Meet',
                            significance: 'First celebration together'
                        },
                        {
                            date: '12-06-2025',
                            event: 'Dhruv\'s Birthday',
                            significance: 'First time someone ordered cake for me'
                        },
                        {
                            date: '20-06-2025',
                            event: 'Science city',
                            significance: 'A day together'
                        },
                        {
                            date: '08-08-2025',
                            event: 'Trisha\'s Badminton Tournament',
                            significance: 'Trisha Won Trophy'
                        },
                        {
                            date: '13-08-2025',
                            event: 'Odoo Meet',
                            significance: 'A good day spent together'
                        },
                    ];
             //   }

              // return specialMoments.slice(0, 5);
            };

            const getDefaultAnalysis = () => ({
                totalMessages: 0,
                totalDays: 0,
                averageMessagesPerDay: 0,
                emojiUsage: {},
                messageTypes: { Text: 0, Photos: 0, Videos: 0, Audio: 0 },
                sentimentAnalysis: { Positive: 0, Neutral: 0, Negative: 0 },
                conversationTopics: { 'Daily Life': 0, 'Future Plans': 0, 'Memories': 0, 'Jokes & Humor': 0 },
                responseTime: { Average: '0 minutes', Fastest: '0 seconds', Longest: '0 minutes' },
                specialMoments: []
            });

            const initializeData = async () => {
                setLoading(true);
                try {
                    console.log('Starting data initialization...');

                    const [fileDataResult, chatDataResult] = await Promise.all([
                        scanFolders(),
                        analyzeChat()
                    ]);

                    console.log('File data result:', fileDataResult);
                    console.log('Chat data result:', chatDataResult);

                    setFileData(fileDataResult);
                    setChatData(chatDataResult);
                    setLastUpdated(new Date().toLocaleTimeString());
                } catch (error) {
                    console.error('Error initializing data:', error);
                    setChatData(getDefaultAnalysis());
                } finally {
                    setLoading(false);
                }
            };

            const refreshData = () => {
                initializeData();
            };

            // Retry mechanism for failed requests
            const fetchWithRetry = async (url, maxRetries = 3) => {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(url);
                        if (response.ok) {
                            return response;
                        }
                        console.warn(`Attempt ${i + 1} failed for ${url}: ${response.status}`);
                    } catch (error) {
                        console.warn(`Attempt ${i + 1} failed for ${url}:`, error);
                    }

                    if (i < maxRetries - 1) {
                        // Wait before retrying (exponential backoff)
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                    }
                }
                return null;
            };

            // Enhanced directory scanning with multiple server configurations
            const scanDirectoryWithFallbacks = async (directoryPath, folderType) => {
                const urls = [
                    directoryPath,
                    directoryPath.replace(/\/$/, ''),
                    directoryPath + 'index.html',
                    directoryPath.replace(/\/$/, '') + '/index.html'
                ];

                for (const url of urls) {
                    try {
                        console.log(`Trying to fetch ${url} for ${folderType}...`);
                        const response = await fetchWithRetry(url);
                        if (response) {
                            const text = await response.text();
                            const files = extractFilesFromHTML(text, folderType);
                            if (files.length > 0) {
                                console.log(`Successfully found ${files.length} files in ${folderType} using ${url}`);
                                return files;
                            }
                        }
                    } catch (error) {
                        console.warn(`Failed to fetch ${url} for ${folderType}:`, error);
                    }
                }

                console.warn(`No files found for ${folderType} with any URL`);
                return [];
            };

            useEffect(() => {
                initializeData();
            }, []);

            useEffect(() => {
                if (chatData && chartRef.current) {
                    if (chartInstance.current) {
                        chartInstance.current.destroy();
                    }

                    const ctx = chartRef.current.getContext('2d');
                    chartInstance.current = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: Object.keys(chatData.messageTypes),
                            datasets: [{
                                data: Object.values(chatData.messageTypes),
                                backgroundColor: [
                                    '#8B5CF6',
                                    '#EC4899',
                                    '#06B6D4',
                                    '#10B981'
                                ],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        padding: 20,
                                        usePointStyle: true
                                    }
                                }
                            }
                        }
                    });
                }

                return () => {
                    if (chartInstance.current) {
                        chartInstance.current.destroy();
                    }
                };
            }, [chatData]);

            // Helper function to download a single file with proper content type
            // Helper function to format file size
            const formatFileSize = (bytes) => {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            };

            const downloadFile = async (filePath, fileName) => {
                try {
                    // Ensure filePath is a valid URL or relative path
                    let actualPath = filePath;
                    
                    // If it's a relative path without leading slash, add one
                    if (!filePath.startsWith('http') && !filePath.startsWith('/') && !filePath.startsWith('./')) {
                        actualPath = `/${filePath}`;
                    }
                    
                    // For local development, use the full path
                    if (!window.location.hostname.includes('netlify.app')) {
                        // Remove any leading slashes to prevent double slashes
                        actualPath = actualPath.replace(/^\/+/, '');
                    }
                    
                    console.log('Attempting to download:', actualPath);
                    
                    const response = await fetch(actualPath, {
                        cache: 'no-cache',  // Disable cache to ensure fresh download
                        headers: { 'Cache-Control': 'no-cache' }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to download ${actualPath}: ${response.status} ${response.statusText}`);
                    }
                    
                    // Get the file extension to determine content type
                    const extension = fileName.split('.').pop().toLowerCase();
                    let contentType = 'application/octet-stream'; // default binary type
                    
                    // Set content type based on file extension
                    const contentTypes = {
                        'jpg': 'image/jpeg',
                        'jpeg': 'image/jpeg',
                        'png': 'image/png',
                        'gif': 'image/gif',
                        'mp4': 'video/mp4',
                        'mp3': 'audio/mpeg',
                        'wav': 'audio/wav',
                        'txt': 'text/plain',
                        'html': 'text/html',
                        'pdf': 'application/pdf'
                    };
                    
                    if (contentTypes[extension]) {
                        contentType = contentTypes[extension];
                    }
                    
                    // Get the blob data
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    
                    // Cleanup
                    setTimeout(() => {
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                    }, 100);
                    
                    console.log(`Successfully downloaded: ${fileName}`);
                    return true;
                } catch (error) {
                    console.error('Download error:', error);
                    alert(`Error downloading file: ${error.message}`);
                    return false;
                }
            };

            // Optimized downloadFiles function with parallel processing and proper cleanup
            // Create a progress modal
            const createProgressModal = (type, totalFiles) => {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                modal.innerHTML = `
                    <div class="bg-white rounded-xl p-6 w-full max-w-md">
                        <h3 class="text-xl font-bold text-gray-800 mb-4">Downloading ${type} (0/${totalFiles})</h3>
                        <div class="w-full bg-gray-200 rounded-full h-4 mb-4">
                            <div id="progressBar" class="bg-blue-600 h-4 rounded-full" style="width: 0%"></div>
                        </div>
                        <div id="progressText" class="text-center text-gray-600 mb-2">Preparing download...</div>
                        <div id="speedText" class="text-center text-sm text-gray-500">-</div>
                        <div id="timeRemaining" class="text-center text-sm text-gray-500">-</div>
                    </div>
                `;
                document.body.appendChild(modal);
                return {
                    update: (current, total, speed, remaining) => {
                        const percent = Math.round((current / total) * 100);
                        const progressBar = modal.querySelector('#progressBar');
                        const progressText = modal.querySelector('#progressText');
                        const speedText = modal.querySelector('#speedText');
                        const timeRemaining = modal.querySelector('#timeRemaining');
                        
                        if (progressBar) progressBar.style.width = `${percent}%`;
                        if (progressText) progressText.textContent = `Downloading ${current} of ${total} files (${percent}%)`;
                        if (speedText) speedText.textContent = speed ? `Speed: ${speed}/s` : '';
                        if (timeRemaining) timeRemaining.textContent = remaining ? `Time remaining: ${remaining}` : '';
                    },
                    close: () => {
                        modal.remove();
                    }
                };
            };

            const downloadFiles = async (type, clickEvent) => {
                console.log('Starting download for type:', type);
                // Prevent multiple clicks
                const downloadButton = clickEvent?.target;
                const originalButtonText = downloadButton?.innerHTML || 'Download';
                
                if (downloadButton) {
                    downloadButton.disabled = true;
                    downloadButton.innerHTML = 'Preparing download...';
                }

                // Track download progress
                let downloadedCount = 0;
                let totalSize = 0;
                let startTime = Date.now();
                let lastUpdateTime = startTime;
                let lastDownloaded = 0;
                let speed = 0;

                try {
                    const files = fileData[type] || [];
                    if (files.length === 0) {
                        alert(`No ${type} files found!`);
                        if (downloadButton) {
                            downloadButton.disabled = false;
                            downloadButton.innerHTML = originalButtonText;
                        }
                        return;
                    }

                    // Create progress modal
                    const progressModal = createProgressModal(type, files.length);
                    
                    // Update progress every 200ms for smooth animation
                    const progressInterval = setInterval(() => {
                        const now = Date.now();
                        const timeDiff = (now - lastUpdateTime) / 1000; // in seconds
                        
                        if (timeDiff > 0) {
                            const newSpeed = Math.round((downloadedCount - lastDownloaded) / timeDiff);
                            speed = Math.round(speed * 0.7 + newSpeed * 0.3); // Smooth speed changes
                            
                            const remainingFiles = files.length - downloadedCount;
                            const remainingTime = speed > 0 ? Math.round(remainingFiles / speed) : 0;
                            const remainingTimeStr = remainingTime > 60 
                                ? `${Math.floor(remainingTime / 60)}m ${remainingTime % 60}s` 
                                : `${remainingTime}s`;
                            
                            progressModal.update(
                                downloadedCount, 
                                files.length,
                                `${speed.toLocaleString()} files`,
                                remainingTime > 0 ? remainingTimeStr : ''
                            );
                            
                            lastUpdateTime = now;
                            lastDownloaded = downloadedCount;
                        }
                    }, 200);

                    // For single files, download directly (no need for zip)
                    if (files.length === 1) {
                        try {
                            console.log('Downloading single file:', files[0]);
                            await downloadFile(files[0].path, files[0].filename);
                            progressModal.update(1, 1, 'Download complete', '');
                            setTimeout(() => progressModal.close(), 1000);
                            return;
                        } catch (error) {
                            console.error('Download failed:', error);
                            alert(`Download failed: ${error.message}`);
                            throw error; // Re-throw to be caught by outer catch
                        } finally {
                            clearInterval(progressInterval);
                            if (downloadButton) {
                                downloadButton.disabled = false;
                                downloadButton.innerHTML = originalButtonText;
                            }
                        }
                    }

                    const JSZip = window.JSZip;
                    const zip = new JSZip();
                    const folder = zip.folder(type);
                    
                    // Process files in parallel with progress tracking
                    const processFile = async (file, index) => {
                        try {
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout
                            
                            const startTime = performance.now();
                            const response = await fetch(file.path, { 
                                signal: controller.signal,
                                cache: 'force-cache',
                                headers: { 'Cache-Control': 'max-age=31536000' } // 1 year cache
                            });
                            clearTimeout(timeoutId);
                            
                            if (!response.ok) throw new Error(`HTTP ${response.status}`);
                            
                            const contentLength = response.headers.get('content-length');
                            const total = contentLength ? parseInt(contentLength, 10) : 0;
                            let loaded = 0;
                            
                            // Use streaming for better memory efficiency
                            const reader = response.body.getReader();
                            const chunks = [];
                            
                            while (true) {
                                const { done, value } = await reader.read();
                                if (done) break;
                                
                                loaded += value.length;
                                chunks.push(value);
                                
                                // Update progress for this file
                                if (total > 0) {
                                    const percent = Math.round((loaded / total) * 100);
                                    const elapsed = (performance.now() - startTime) / 1000;
                                    const speed = loaded / elapsed;
                                    
                                    // Update every 200ms or when 5% progress is made
                                    if (index % 5 === 0 || percent % 5 === 0) {
                                        const remainingTime = speed > 0 ? Math.round((total - loaded) / speed) : 0;
                                        const speedKBps = (speed / 1024).toFixed(1);
                                        progressModal.update(
                                            downloadedCount, 
                                            files.length,
                                            `File ${index + 1}/${files.length} (${percent}%) - ${speedKBps}KB/s`,
                                            remainingTime > 0 ? `${remainingTime}s remaining` : ''
                                        );
                                    }
                                }
                            }
                            
                            const blob = new Blob(chunks);
                            folder.file(file.filename, blob);
                            
                            // Update global progress
                            downloadedCount++;
                            totalSize += blob.size;
                            
                            return true;
                            
                        } catch (error) {
                            console.error(`Failed to process ${file.filename}:`, error);
                            return false;
                        }
                    };
                    
                    // Process files in parallel with concurrency control
                    const CONCURRENT_DOWNLOADS = 5;
                    const downloadQueue = [...files];
                    const activeDownloads = [];
                    let completedCount = 0;
                    
                    // Process queue with concurrency control
                    const processQueue = async () => {
                        while (downloadQueue.length > 0 && activeDownloads.length < CONCURRENT_DOWNLOADS) {
                            const file = downloadQueue.shift();
                            if (!file) continue;
                            
                            const downloadPromise = processFile(file, completedCount + activeDownloads.length + 1)
                                .finally(() => {
                                    const index = activeDownloads.indexOf(downloadPromise);
                                    if (index > -1) {
                                        activeDownloads.splice(index, 1);
                                    }
                                    completedCount++;
                                    processQueue(); // Process next in queue
                                });
                            
                            activeDownloads.push(downloadPromise);
                        }
                        
                        // Update progress
                        progressModal.update(
                            completedCount,
                            files.length,
                            `Downloading... (${completedCount}/${files.length})`,
                            ''
                        );
                        
                        // If queue is empty but downloads are still active, wait for them to finish
                        if (downloadQueue.length === 0 && activeDownloads.length > 0) {
                            await Promise.all(activeDownloads);
                        }
                    };
                    
                    // Start processing
                    await processQueue();

                    // Prepare for download
                    const zipBlob = await zip.generateAsync(
                        {
                            type: 'blob',
                            compression: 'DEFLATE',
                            compressionOptions: { level: 6 },
                            streamFiles: true
                        },
                        (metadata) => {
                            const percent = Math.round((metadata.currentFile / metadata.total) * 100);
                            progressModal.update(
                                files.length,
                                files.length,
                                `Compressing archive... (${percent}%)`,
                                ''
                            );
                        }
                    );

                    // Create and trigger download
                    const downloadUrl = window.URL.createObjectURL(zipBlob);
                    const downloadLink = document.createElement('a');
                    downloadLink.href = downloadUrl;
                    downloadLink.download = `${type}_${new Date().toISOString().split('T')[0]}.zip`;
                    
                    // Show completion in UI
                    progressModal.update(
                        files.length,
                        files.length,
                        'Download ready!',
                        'Preparing download...'
                    );
                    
                    // Small delay to ensure UI updates are visible
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Trigger download
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    
                    // Update UI and clean up
                    progressModal.update(
                        files.length,
                        files.length,
                        'Download complete!',
                        `Downloaded ${files.length} files (${formatFileSize(totalSize)})`
                    );
                    
                    // Clean up after a short delay
                    setTimeout(() => {
                        window.URL.revokeObjectURL(downloadUrl);
                        document.body.removeChild(downloadLink);
                        progressModal.close();
                        
                        if (downloadButton) {
                            downloadButton.disabled = false;
                            downloadButton.innerHTML = 'Download Complete!';
                            setTimeout(() => {
                                downloadButton.innerHTML = originalButtonText;
                            }, 2000);
                        }
                    }, 1000);
                    
                    console.log(`Successfully processed ${files.length} ${type} files (${formatFileSize(totalSize)})`);

                } catch (error) {
                    console.error(`Error downloading ${type} files:`, error);
                    alert(`Error: ${error.message}`);
                    if (downloadButton) {
                        downloadButton.disabled = false;
                        downloadButton.innerHTML = 'Try Again';
                    }
                } finally {
                    clearInterval(progressInterval);
                    alert(`Error downloading ${type} files: ${error.message}`);
                }
            };

            if (loading) {
                return (
                    <div className="min-h-screen gradient-bg flex items-center justify-center">
                        <div className="text-white text-center">
                            <div className="animate-spin rounded-full h-16 w-16 border-b-2 border-white mx-auto mb-4"></div>
                            <p className="text-xl">Loading analysis...</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen bg-gray-50">
                    {/* Header */}
                    <div className="gradient-bg text-white p-8">
                        <div className="max-w-7xl mx-auto">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h1 className="text-4xl font-bold mb-2">Our Analysis</h1>
                                    <p className="text-lg opacity-90">Discovering the patterns in our beautiful journey together.</p>
                                    <p className="text-sm opacity-75 mt-2">Last updated: {lastUpdated}</p>
                                </div>
                                <div className="flex space-x-4">
                                    <button
                                        onClick={refreshData}
                                        className="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg font-semibold transition-colors flex items-center space-x-2"
                                    >
                                        <span>ðŸ”„</span>
                                        <span>Refresh</span>
                                    </button>
                                    <button
                                        onClick={() => window.location.href = 'index.html'}
                                        className="bg-purple-600 hover:bg-purple-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors flex items-center space-x-2"
                                    >
                                        <span>â†</span>
                                        <span>Back to Main</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Navigation Tabs */}
                    <div className="bg-white shadow-sm">
                        <div className="max-w-7xl mx-auto">
                            <div className="flex space-x-1 p-4">
                                {[
                                    { id: 'overview', name: 'Overview', icon: 'ðŸ“Š' },
                                    { id: 'messages', name: 'Messages', icon: 'ðŸ’¬' },
                                    { id: 'emotions', name: 'Emotions', icon: 'â¤ï¸' },
                                    { id: 'timeline', name: 'Timeline', icon: 'ðŸ“…' },
                                    { id: 'downloads', name: 'Downloads', icon: 'ðŸ“' }
                                ].map(tab => (
                                    <button
                                        key={tab.id}
                                        onClick={() => setActiveTab(tab.id)}
                                        className={`px-6 py-3 rounded-lg font-semibold transition-all flex items-center space-x-2 ${
                                            activeTab === tab.id ? 'tab-active' : 'text-gray-600 hover:bg-gray-100'
                                        }`}
                                    >
                                        <span>{tab.icon}</span>
                                        <span>{tab.name}</span>
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* Content */}
                    <div className="max-w-7xl mx-auto p-8">
                        {activeTab === 'overview' && <OverviewTab chatData={chatData} chartRef={chartRef} />}
                        {activeTab === 'messages' && <MessagesTab chatData={chatData} />}
                        {activeTab === 'emotions' && <EmotionsTab chatData={chatData} />}
                        {activeTab === 'timeline' && <TimelineTab chatData={chatData} />}
                        {activeTab === 'downloads' && <DownloadsTab fileData={fileData} onDownload={downloadFiles} />}
                    </div>
                </div>
            );
        };

        const OverviewTab = ({ chatData, chartRef }) => (
            <div className="space-y-8">
                {/* Statistics Cards */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                    <div className="bg-white rounded-xl p-6 card-shadow">
                        <div className="text-3xl font-bold text-purple-600 mb-2">{chatData?.totalMessages || 0}</div>
                        <div className="text-gray-600">Total Messages</div>
                    </div>
                    <div className="bg-white rounded-xl p-6 card-shadow">
                        <div className="text-3xl font-bold text-purple-600 mb-2">{chatData?.totalDays || 0}</div>
                        <div className="text-gray-600">Days Together</div>
                    </div>
                    <div className="bg-white rounded-xl p-6 card-shadow">
                        <div className="text-3xl font-bold text-purple-600 mb-2">{chatData?.averageMessagesPerDay?.toFixed(1) || 0}</div>
                        <div className="text-gray-600">Messages/Day</div>
                    </div>
                </div>

                {/* Platform Breakdown */}
                {chatData?.breakdown && (
                    <div className="bg-white rounded-xl p-6 card-shadow">
                        <h3 className="text-xl font-bold text-gray-800 mb-4">Platform Breakdown</h3>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            {chatData.breakdown.instagram && (
                                <div className="bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg p-4">
                                    <div className="flex items-center mb-3">
                                        <span className="text-2xl mr-2">ðŸ“±</span>
                                        <h4 className="font-semibold text-gray-800">Instagram</h4>
                                    </div>
                                    <div className="space-y-2 text-sm">
                                        <div className="flex justify-between">
                                            <span>Messages:</span>
                                            <span className="font-semibold">{chatData.breakdown.instagram.totalMessages}</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span>Days:</span>
                                            <span className="font-semibold">{chatData.breakdown.instagram.totalDays}</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span>Avg/Day:</span>
                                            <span className="font-semibold">{chatData.breakdown.instagram.averageMessagesPerDay?.toFixed(1)}</span>
                                        </div>
                                    </div>
                                </div>
                            )}
                            {chatData.breakdown.whatsapp && (
                                <div className="bg-gradient-to-r from-green-50 to-teal-50 rounded-lg p-4">
                                    <div className="flex items-center mb-3">
                                        <span className="text-2xl mr-2">ðŸ’¬</span>
                                        <h4 className="font-semibold text-gray-800">WhatsApp</h4>
                                    </div>
                                    <div className="space-y-2 text-sm">
                                        <div className="flex justify-between">
                                            <span>Messages:</span>
                                            <span className="font-semibold">{chatData.breakdown.whatsapp.totalMessages}</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span>Days:</span>
                                            <span className="font-semibold">{chatData.breakdown.whatsapp.totalDays}</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span>Avg/Day:</span>
                                            <span className="font-semibold">{chatData.breakdown.whatsapp.averageMessagesPerDay?.toFixed(1)}</span>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                )}

                {/* Additional Statistics */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                    <div className="bg-white rounded-xl p-6 card-shadow">
                        <div className="text-3xl font-bold text-purple-600 mb-2">{chatData?.responseTime?.Average || '0 minutes'}</div>
                        <div className="text-gray-600">Avg Response Time</div>
                    </div>
                </div>

                {/* Chart */}
                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6 text-center">Message Types Distribution</h3>
                    <div className="h-96">
                        <canvas ref={chartRef}></canvas>
                    </div>
                </div>
            </div>
        );

        const MessagesTab = ({ chatData }) => (
            <div className="space-y-8">
                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Message Analysis</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <h4 className="text-lg font-semibold text-gray-700 mb-4">Message Types</h4>
                            <div className="space-y-3">
                                {Object.entries(chatData?.messageTypes || {}).map(([type, count]) => (
                                    <div key={type} className="flex justify-between items-center">
                                        <span className="text-gray-600">{type}</span>
                                        <span className="font-semibold text-purple-600">{count}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                        <div>
                            <h4 className="text-lg font-semibold text-gray-700 mb-4">Response Times</h4>
                            <div className="space-y-3">
                                {Object.entries(chatData?.responseTime || {}).map(([type, time]) => (
                                    <div key={type} className="flex justify-between items-center">
                                        <span className="text-gray-600">{type}</span>
                                        <span className="font-semibold text-purple-600">{time}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        );

        const EmotionsTab = ({ chatData }) => (
            <div className="space-y-8">
                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Sentiment Analysis</h3>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                        {Object.entries(chatData?.sentimentAnalysis || {}).map(([sentiment, percentage]) => (
                            <div key={sentiment} className="text-center">
                                <div className="text-4xl font-bold text-purple-600 mb-2">{percentage}%</div>
                                <div className="text-gray-600">{sentiment}</div>
                            </div>
                        ))}
                    </div>
                </div>

                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Most Used Emojis</h3>
                    <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                        {Object.entries(chatData?.emojiUsage || {})
                            .sort(([,a], [,b]) => b - a)
                            .slice(0, 12)
                            .map(([emoji, count]) => (
                                <div key={emoji} className="text-center p-4 bg-gray-50 rounded-lg">
                                    <div className="text-3xl mb-2">{emoji}</div>
                                    <div className="text-sm text-gray-600">{count}</div>
                                </div>
                            ))}
                    </div>
                </div>
            </div>
        );

        const TimelineTab = ({ chatData }) => (
            <div className="space-y-8">
                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Special Moments</h3>
                    <div className="space-y-4">
                        {chatData?.specialMoments?.map((moment, index) => (
                            <div key={index} className="border-l-4 border-purple-500 pl-6 py-4">
                                <div className="font-semibold text-gray-800">{moment.event}</div>
                                <div className="text-sm text-gray-500">{moment.date}</div>
                                <div className="text-gray-600 mt-1">{moment.significance}</div>
                            </div>
                        ))}
                    </div>
                </div>

                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Conversation Topics</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        {Object.entries(chatData?.conversationTopics || {}).map(([topic, percentage]) => (
                            <div key={topic} className="flex justify-between items-center p-4 bg-gray-50 rounded-lg">
                                <span className="text-gray-700">{topic}</span>
                                <span className="font-semibold text-purple-600">{percentage}%</span>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        );

        const DownloadsTab = ({ fileData, onDownload }) => (
            <div className="space-y-8">
                <div className="bg-white rounded-xl p-8 card-shadow">
                    <h3 className="text-2xl font-bold text-gray-800 mb-6">Download Your Memories</h3>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div className="text-center p-6 bg-pink-50 rounded-lg">
                            <div className="text-4xl mb-4">ðŸ“¸</div>
                            <h4 className="text-lg font-semibold text-gray-800 mb-2">Photos</h4>
                            <p className="text-gray-600 mb-4">{fileData.photos.length} files</p>
                            <button
                                onClick={() => onDownload('photos')}
                                className="bg-pink-500 hover:bg-pink-600 text-white px-6 py-2 rounded-lg font-semibold transition-colors"
                            >
                                Download Photos
                            </button>
                        </div>
                        <div className="text-center p-6 bg-blue-50 rounded-lg">
                            <div className="text-4xl mb-4">ðŸŽµ</div>
                            <h4 className="text-lg font-semibold text-gray-800 mb-2">Audio</h4>
                            <p className="text-gray-600 mb-4">{fileData.audio.length} files</p>
                            <button
                                onClick={() => onDownload('audio')}
                                className="bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg font-semibold transition-colors"
                            >
                                Download Audio
                            </button>
                        </div>
                        <div className="text-center p-6 bg-green-50 rounded-lg">
                            <div className="text-4xl mb-4">ðŸŽ¬</div>
                            <h4 className="text-lg font-semibold text-gray-800 mb-2">Videos</h4>
                            <p className="text-gray-600 mb-4">{fileData.videos.length} files</p>
                            <button
                                onClick={() => onDownload('videos')}
                                className="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg font-semibold transition-colors"
                            >
                                Download Videos
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        );

        ReactDOM.render(<App />, document.getElementById('app'));
    </script>
</body>
</html>
